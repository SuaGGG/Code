# 操作系统复习

## 操作系统基本概念

### 操作系统的定义和作用

#### 定义: 没有一个关于操作系统的完全准确的定义 

一个比较公认的定义是：操作系统是一直运 行在计算机上的程序（通常称为内核）。

 操作系统是管理系统资源、控制程序执行、 改善人机交互，为其它软件系统提供支持的 一种系统软件，是软件系统的核心。 

#### 作用

1.让程序的运行更容易(允许多个程序运行) 。 

2. 允许程序共享内存。
3.  让程序能够与设备交互。

### 操作系统的功能

#### 管理计算机系统的软硬件资源

处理机 - 进程管理

存储器 - 内存管理

设备     - 设备管理

文件     - 文件系统管理

#### 提供保护与安全

控制进程或用户访问计算机系统资源

防止系统不受外部或内部的攻击

### 操作系统的特征

#### 并发

在同一时间间隔内发生两个或多个事件， 宏观上看是同时发生，微观上看是多个事件交替发生。

#### 共享

系统中的资源可供多个并发执行的进程共同使用。

​	互斥共享：一段时间只允许一个进程访问

​	同时访问：一段时间允许多个进程访问

​	时分复用，空分复用

​		并发与共享互为存在条件

​			程序的并发执行带来资源共享问题；

​			系统对资源共享的管理影响到程序并发执行的效率

#### 虚拟

把一个物理上的实体变为若干个逻辑上的对应物

​		分时技术，虚拟内存，虚拟设备

#### 异步

任务的执行顺序和每个任务的执行时间是不确定的

### 操作系统的分类

#### 批处理系统(多道程序设计)

批处理系统将作业(代码和数据)组织起来，使CPU始终有一个作业可以执行

系统中的作业的子集将被保留在内存中

通过作业调度选择并运行一个作业

当作业必须等待，操作系统会切换到另一个作业

##### 批处理技术

批处理技术时指计算机系统对一批作业自动进行处理的一种技术。

早期的批处理分为：**联机批处理**，**脱机批处理**。

###### 联机批处理

通过将若干个作业合成一批通过输入设备输入到磁带，接着通过**监督程序**自动把磁带上该批作业的第一个调入内存编译，然后由**装配程序**把编译结果装入内存启动执行，该作业运行结束后输出结果。然后重复执行上述操作，直到该批作业结束。

**联机批处理的不足**：联机批处理中采用**联机输入/输出**，即输入/输出操作在主机控制下进行，其缺点是**速度慢**。

###### 脱机批处理

在脱机批处理系统中，除主机外另设一台外围机。

用户作业通过外围机输入到磁带上，而主机只负责从磁带上把作业调入内存，并予以执行。

作业完成后，主机负责把结果输出到磁带上，然后再由外围机把磁带上的信息在打印机上输出。

![1703513779293](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703513779293.png)

**脱机输入/输出的优点：**

1.减少了CPU的空闲时间。

2.提高了I/O速度。

##### 单道批处理系统

内存中始终只保持一道作业的批处理系统。

**特征**：

1.自动性: 自动依次运行, 无人工干预.

2.顺序性:完成顺序与进入顺序相同.

3.单道性:内存只有一道作业.

#####  单CPU系统中多道程序运行特点 

1. **多道**: 计算机内存中同时存放多道相互独立的程序
2. **宏观上并行**:同时进入系统的多道程序都处于运行过程中，即它们先后开始了各自的 运行，但都未运行完毕
3.  **微观上串行**：内存中的多道程序轮流占有  CPU，交替执行

#####  多道批处理系统要解决的问题

1. 处理机管理: 如何分配回收处理机
2. 内存管理:  内存分配回收, 信息保护
3. 设备管理: 设备分配回收, 缓冲管理
4. 文件管理: 文件存储, 共享保护及检索
5. 作业管理: 作业合理搭配

#####  多道批处理系统的特征：

1. 多道性: 计算机内存中同时存放几道相互独立的程序
2. 无序性: 进入顺序与完成顺序无严格对应关系
3. 调度性: 作业从提交到完成经历两级调度: 作业调度, 进程调度



#### 分时系统(多任务处理)

CPU频繁切换作业，使用户能够在作业运行时与其交互，从而创建交互式运算

1. 响应时间应小于1秒
2. 每个用户至少有一个在内存中执行的程序，称为进程
3. 如果有多个作业同时准备进行，将进行CPU调度
4. 如果进程不能完全放入内存中，则进行交换以运行
5. 虚拟内存允许执行部分未完全加载到内存中的进程

在分时操作系统中,

1. 一个计算机和许多终端设备连接, 每个用户可以通过终端向系统发出命令, 请求完成某项工作, 而系统则分析从终端设备发来的命令, 完成用户提出的要求,
2. 然后用户再根据系统提供的运行结果, 向系统提出下一步请求
3. 这样重复上述交互会话过程, 直到用户完成全部工作为止

##### 分时技术

1. 把处理机的运行时间分成很短的时间片, 按时间片轮流把处理机分配给各联机作业使用
2. 若某个作业在分配给它的时间片内不能完成其计算, 则该作业暂停运行, 把处理机让给另一个作业使用, 等待下一轮时再继续其运行

#####  分时系统实现中的关键问题 

1. 及时接收: 设置多路卡
2. 及时处理: 时间片轮转

#####  分时操作系统的特征 

1. **同时性**: 一台计算机与若干台终端相连接, 终端上的这些用户可以同时使用计算机
2. **交互性**:用户通过终端采用人机会话的方式直接控制程序运行, 同程序进行交互
3. **独立性**:用户彼此之间都感受不到别人也在使用这台计算机, 好像只有自己独占计算机一样
4. **及时性**: 用户请求能在很短时间内获得响应

#### 实时系统

**实时系统**是指系统能及时响应外部事件的请求, 在规定的时间范围内完成对该事件的处理, 并控制实时任务协调一致地运行

##### 实时系统分类

1. 实时控制系统: 指以计算机为中心的生产过程控制系统
2. 实时信息处理系统: 要求对信息进行实时处理的系统

##### 实时系统的特征

1. 及时性: 响应时间由控制对象决定
2. 可靠性: 高可靠性

#### 个人计算机操作系统

**个人计算机操作系统**主要供个人使用, 它功能强, 价格便宜, 能满足一般人工作, 学习, 游戏等方面的要求

**个人计算机操作系统的主要特点**是计算机在某一段时间内为单个用户服务, 采用图形界面人机交互的工作方式, 界面友好, 使用方便

#### 网络操作系统

**网络操作系统**是基于计算机网络的, 是在各种计算机操作系统上按网络体系结构协议标准开发的**软件**

包括网络管理, 通信, 资源共享, 系统安全和各种网络应用服务, 其**目标是互相通信及资源共享**

#### 分布式操作系统

**分布式操作系统**是指多个分散的处理单元经互连网络连接而形成的系统,其中每个处理单元既具有高度自治又相互协同, 能在系统范围内实现资源管理, 任务动态分配, 并能并行地运行分布式程序

#### 嵌入式操作系统

对整个智能芯片以及它所控制地各种部件模块等资源进行统一调度, 指挥和控制的系统软件成为**嵌入式操作系统**

嵌入式系统几乎包括了生活中的所有电器设备, 如掌上PDA, 微波炉, 数字相机, 自动售货机, 工业自动化仪表与医疗仪器等

#### 分布式操作系统与网络操作系统的比较

1. **分布性**:分布式操作系统的处理和控制功能较均匀分布在系统的各个站点上; 而网络系统中控制功能大多集中在网络服务器上
2. **并行性**: 分布式操作系统中的任务分配程序可将多个任务分配到系统的多个处理单元上并行执行;而网络操作系统中每个用户的任务通常在自己的计算机上处理.
3. **透明性**:分布式系统能很好隐藏系统内部的实现细节, 对象的物理位置, 并发控制及系统故障等对用户是透明的; 而网络操作系统中主要是操作实现上的透明
4. **共享性**: 分布式操作系统中各站点上的资源可供所有用户共享; 而网络操作系统中共享的资源主要设置在服务器上
5. **健壮性**: 由于分布式系统的控制功能分布, 当站点故障时可以通过容错来重构系统以保证系统正常运行; 而网络操作系统中控制功能主要集中在服务器上, 使系统具有潜在的不可靠性



### 操作系统的基本类型

#### 三种基本类型

1. 批处理操作系统
2. 分时操作系统
3. 实时操作系统

#### 通用操作系统

**通用操作系统**是指一个操作系统兼由批处理, 分时和实时操作系统三者或两者的功能

### 操作系统的结构

#### 操作系统复杂度管理办法

管理复杂度系统的重要办法: **M.A.L.H**

1. **模块化**: 将复杂系统分解为一系列模块,通过明确定义的接口进行交互, 高内聚, 低耦合
2. **抽象**: 接口与内部实现分离, 模块通过抽象的接口进行交互, 而无需关心模块的内部实现
3. **分层**: 将模块按一定的原则进行层次划分，约 束模块只能同层或与相邻层交互 
4. **层级**: 功能相近的模块组成具有清晰接口的自 包含子系统，子系统再递归地组成有清晰接口 的更大子系统 

#### 分层结构

**分层结构**其实是一种**模块化思想**. 分层结构就和盖楼一样, 最底层为硬件层, 最高层为用户层, 每层只使用低层次的功能和服务, 也就是说上层可以调用下层的服务但不可以调用其它层的服务.

 ![img](https://pic2.zhimg.com/80/v2-96694fa5cea960383d33e7e03ce16e91_720w.webp) 

**分层结构的优点**: 简化了系统设计, 便于维护和升级维护

**分层结构的缺点**: 层的定义困难以及效率差.

#### 宏内核结构

所有的系统功能都放在内核里(宏内核结构在操作系统中也通常也采用了"模块化"思想)

**宏内核结构的优点**: 运行效率高

**宏内核结构的缺点**: 结构难以理解, 难以维护, 随着复杂性的增加, 可靠性和安全性难以保障

#### 微内核结构

微内核结构基于客户/服务器模型, 由微内核和核外用户空间的服务器进程构成

微内核保留进程管理, 内存管理和通信功能, 通过信息传递使客户程序与服务程序进行通信

**微内核结构的优点**: 易于扩展, 易于移植, 更可靠(内核代码少), 更安全

**微内核结构的缺点**: 用户空间到内核空间的通信增加了系统开销, 早期性能不及宏内核结构

#### 模块化结构

模块功能独立, 且被封装, 具有良好定义的接口

现代OS (如Unix, Linux, Windows等) 均采用模块化的策略组织各功能

没有商业OS是纯粹采用模块化结构设计

**模块化结构的优点**: 易于理解, 效率高

**模块化结构的缺点**: 全局函数使用多造成访问控制困难, 结构不清晰会导致可理解性, 可维护性及可移植性差, 存在潜在的性能退化

#### 混合结构

现代OS往往采用的不是单一模型

1. 混合模型结合多种方法来满足性能, 安全性和可用性需求
2. Linux 和 Solaris 是单内核结构, 但它们也是模块化的, 可动态向内核添加新功能
3. Windows也是单内核结构, 但也保留了微内核的模式来支持子系统, 也提供可加载的内核模块
4. MacOS是混合, 分层的系统, 采用Mach微内核与部分BSD Unix构成内核, 且有可动态加载的模块

###  操作系统的引导过程

#### 操作系统的构建和启动

OS 可运行于各种不同的系统上

从源码开始构建OS

1. 获取OS源码
2. 为某系统即将构建的OS配置参数
3. 编译OS
4. 安装OS
5. 启动计算机并运行OS

预编译的OS可能过于通用而无法支持特定的硬件

###### 构建Linux操作系统

1. 从http://www.kernel.org下载Linux源代码 
2. 使用“make menuconfig”命令配置内核。这一步生成 .config配置文件。
3. 使用“make”命令编译主内核。make命令根据.config文 件中的配置参数编译内核，生成内核镜像文件vmlinuz。
4. 使用“make modules”命令编译内核模块。与编译内核 类似，模块的编译也依赖于.config文件中指定的配置参 数。 
5. 使用“make modules install”命令将内核模块安装到 vmlinuz中。 
6. 使用“make install”命令将新内核安装到系统中。 

##### OS的引导过程(滚雪球方式)

1. 初始引导
    1. 系统加电
    2. 执行初始引导程序, 对系统硬件和配置进行自检, 保证系统没有硬件错误
    3. 从硬盘中读入操作系统引导程序, 并将控制权交给该程序模块
2. 引导程序执行
    1. 引导程序执行, 将操作系统核心文件读入内存, 并将控制交给核心的初始化程序
3. 内核初始化, 初始化系统数据结构及参数
    1. 系统加电建立进程有关的数据结构
    2. 获得自由存储空间的容量, 建立存储管理的数据结构
    3. 建立系统设备和文件系统的数据结构
    4. 初始化时钟
4. 系统初始化
    1. 完善OS的操作环境, 装载命令处理程序(或图形用户界面), 并初始化
    2. 在多用户系统中, 为每一个终端建立命令解释进程, 使系统处于命令接收状态

##### OS的启动流程

1. 引导加载程序加载OS内核到内存中
2. 内核初始化: OS内核进行一系列的初始化操作, 如硬件设备检查, 加载驱动, 内存管理等
3. 内核启动init进程: 内核初始化完成后, 会启动init进程(在Linux中) 或systemd进程, 该进程是所有其他进程的父进程
4. 用户空间程序启动: init进程根据系统的配置, 启动一系列的用户空间程序, 如 Shell, 图形界面等

#### 应用程序的处理步骤

1. 编辑: 建立一个新文件, 或对已有的文件中的错误进行修改
2. 编译: 将源程序翻译成浮动的目标代码
3. 连接: 主程序和其他所需要的子程序和例行程序连接装配在一起, 使之成为一个可执行的, 完整的主存映像文件
4. 运行: 将主存映像文件调入主存, 启动运行, 得出计算结果

##### 一个程序的典型执行流程

1. 加载: 当启动一个程序时, 由OS的加载器将该程序的可执行文件加载到内存中
2. 运行: OS创建一个新的进程, 并将CPU的控制权交给该进程. 该新进程开始执行加载到内存中的程序代码
3. 系统调用: 当程序需要进行一些特权操作(如读写文件, 发送网络数据等)时, 它将发起系统调用
4. 中断和信号: 程序的执行可能会被中断和信号打断. 中断通常是由硬件事件出发的, 如I/O操作的完成, 定时器的超时等. 信号则是一种软件中断, 可以由其他进程或者内核发送
5. 退出: 当程序执行完成或者由于某种原因需要停止时, 它将执行退出操作, 包括释放资源, 关闭打开的文件, 通知父进程等.

##  操作系统运⾏环境与运⾏机制

### 重要寄存器的作用

#### CPU的工作流程

1. 取指：CPU读取程序计数器（PC）中的地址作为指令的地址，从内存中读取指令。 
2. 译码：CPU将取得的指令进行译码，以确定它要执行的操作。
3. 执行：CPU执行指令的操作，可能涉及到算术、 逻辑、移位等操作。
4. 写回：CPU将执行结果写回到寄存器或内存中。 

#### CPU中的重要寄存器

1. 程序计数器（PC）：用于记录下一条要执行的指令的地址。当处理器执行完一条指令后，PC寄存器会自动更新为下一条指令的地址。 
2. 指令寄存器（IR）：IR寄存器用于记录最近取出并解码的指令。
3. 程序状态字（PSW）寄存器：PSW寄存器用于记录处理器的运行 状态，如条件码、模式、控制位等。PSW寄存器中的一些位可以影响处理器的行为，如中断允许位、处理器状态位等。
4. 通用寄存器（General Registers）：通用寄存器是一组可以被用户程序和操作系统程序使用的寄存器，用于保存数据或地址。 
5.  控制寄存器（Control Registers）：控制寄存器是一组只能被操作系统程序使用的寄存器，用于控制和配置处理器的一些特性和功能。 

### 操作系统的用户态和内核态

**CPU态**: 又称CPU的特权级, 是CPU的工作状态. 当前CPU正在执行哪类程序, 决定CPU的态.

区分处理机状态的目的: 保护操作系统

**内核态**:  操作系统的管理程序执行时机器所处的状态， 在此状态下处理机可使用全部指令(包括一组特权指令)；使用全部系统资源(包括整个存储区域)。 

**用户态**:  用户程序执行时CPU所处的状态，在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域。 

#### 用户态与内核态的区别

![1703536136697](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703536136697.png)

**CPU的特权指令集**: 涉及外部设备的输入/输出指令, 修改特殊寄存器的指令, 改变机器状态的指令

#### 不同架构的CPU的特权级

1. **ARM架构**: 定义了四个特权级别, 分别是User (用户模式), FIQ(快速中断模式), IRQ(中断请求模式) 和 SVC(超级用户模式). 用户模式是普通应用程序运行的模式, 而其他三种模式主要用于处理各种中断和异常
2. **RISC-V架构**:定义了四种特权级别, 分别是User(U), Supervisor(S), Hypervisor(H), Machine(M). User级别用于运行用户程序, Supervisor级别用于运行操作系统内核, Hypervisor级别用于运行虚拟机管理器, Machine级别则是硬件级别, 具有最高的特权
3. **X86架构**: 定义了四个特权级别, 从 Ring 0 到 Ring 3. 其中, Ring 0具有最高特权, 通常用于操作系统内核. Ring 1 到 Ring 2 很少使用, 而Ring 3具有最低特权, 用于运行用户程序

#### CPU特权级切换的三个场景

1. 应用程序调用操作系统提供的系统调用, 此时应用程序通过执行系统调用指令将CPU的特权级从用户态切换到内核态
2. 应用程序执行一条指令触发异常, 导致CPU的特权级从用户态切换到内核态, 比如访问内存指令触发了异常
3. 应用程序执行过程中, CPU收到了一条来自外设的**中断**, 对中断的处理导致CPU的特权级从用户态切换到内核态

### 中断和异常的工作原理

#### 中断机制中的常见功能

1. 中断一般通过中断向量将控制权转移到中断服务例程,  中断向量包含所有服务例程的地址
2. 中断架构必须保存被中断指令的地址
3. Trap或者异常是由错误或用户请求引起的软件生成的中断
4. 操作系统是中断驱动的

#### 中断响应

1. **中断响应**: 当中央处理机CPU发现已有中断请求时, 中止现行程序执行, 并自动引出中断处理程序的过程.
2. 中断响应需要硬件支持
    1. PC - 程序计数器
    2. PSW - 状态寄存器
    3. 系统堆栈 - 内存的固定区域
    4. 中断向量表 - 内存的固定区域

保护现场和恢复现场

**现场**: 在中断的那一时刻能确保程序继续运行的有关信息

1. 后继指令所在主存的单元号
2. 程序运行所处的状态
3. 指令执行情况
4. 程序执行的中间结果等

##### 保护现场

当中断发生时, 必须立即把现场信息保存在主存中

##### 恢复现场

程序重新运行之前, 把保留的该程序现场信息从主存中送至相应的指令计数器, 通用寄存器或一些特殊的寄存器中

#### 中断响应的详细过程

1. 中断响应过程
    1. 保留程序断点及CPU的状态信息
    2. 自动转入相应的中断处理程序
2. 中断响应的实质
    1. 交换指令的地址和CPU的状态信息

#### 中断处理程序

当硬件完成了中断进入过程后, 由相应的中断处理程序得到控制权, 进入了 软件的中断处理过程

![1703540560991](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703540560991.png)

#### 中断分类

1. 按中断来源分
    1. **中断**: 由处理机外部事件引起的中断
    2. **Trap**: 由处理机内部事件引起的中断
2. 按中断功能分类
    1. **输入输出中断**: I/O传输结束或出错中断
    2. **外中断**: 时钟中断, 操作员控制台中断, 通信中断等
    3. **机器故障中断**: 电源故障, 主存取指令错误等
    4. **程序性中断**: 定点溢出, 用户态下用内核态指令
    5. **访管中断**: 对操作系统提出某种需求时所发出的中断, 非法操作有时也被称为系统调用, 陷阱或者软件中断
3. 按中断方式分类
    1. **强迫性中断**: 不是正在运行的程序所期待的中断, 如: 输入输出中断, 外中断, 机器故障中断, 程序性中断
    2. **自愿中断**: 是运行程序所期待的事件. 如: 访管中断

### 系统调用的过程

**系统调用**

1. 是操作系统提供的服务的编程端口
2. 通常用高级语言编写
3. 大多数程序通过高级应用程序编程接口(API) 而不是直接使用系统调用
4. 最常见的三个API: Windows的Win32 API, 基于POSIX 的系统(包括几乎所有版本的UNIX, Linux 和 Mac OS X) 的 POSIX API, 以及 Java 虚拟机(JVM) 的 Java API

![1703541683146](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703541683146.png)

#### 系统调用的实现

1. 每个系统调用都与一个编号相关联

    系统调用接口根据这些编号维护一个索引表

2. 系统调用接口在操作系统内核中调用所需的系统调用, 并返回系统调用的状态和任何返回值

3. 调用者不需要了解系统调用的具体实现方式

    1. 只需要遵守API 并理解操作系统对调用的结果会做什么
    2. API将操作系统接口的大部分细节隐藏起来, 对程序员不可见
        1.  由运行时支持库管理（一组内置于编译器所包含的库中的 函数） 

####  访管中断 

1.  当处理机执行到访管指令时发生中断，该中断称 为访管中断，它表示正在运行的程序对操作系统 的某种需求。      

2. 操作系统提供实现各种功能的例行子程序，其中 的每一个功能对应访管指令的一个功能号。例如: 

    ​	svc  0 - 显示一个字符

    ​	svc  1 - 打印一个字符串

3. 系统调用是用户在程序一级请求操作系统服务的 一种手段，它是带有一定功能号的“访管指令”。 其功能是由操作系统中的程序完成的，即由软件 方法实现的。 

#### 系统调用的实现

![1703542309523](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703542309523.png)

#### 系统调用的参数传递

1. 除了所需系统调用的标识符之外, 还需要更多的信息
2. 具体的信息类型和数量根据操作系统和调用而变化
3. 由三种常见的方法用于将参数传递给操作系统
    1. 将参数传递到寄存器中, 在某些情况下, 可能会有多个参数超过寄存器数量
    2. 将参数存储在内存中的快或者表中,  并将块的地址作为参数传递到寄存器中
    3. 程序将参数放置或推送到堆栈中, 并由操作系统从堆栈中弹出
    4. 快和堆栈方法不限制传递的参数数量或长度

#### 系统调用的类型

1. 进程控制    Process control 
2. 文件管理    File management 
3. 设备管理    Device management 
4. 信息维护    Information maintenance 
5. 通信            Communications 
6. 保护            Protection 

#### 为什么应用程序是OS特定的

1.  在一个系统上编译的应用程序通常无法在其他操作系统 上执行 

2. 每个操作系统都提供自己独特的系统调用 

    拥有自己的文件格式等 

3. 应用程序可以是多操作系统的 

    1. 使用解释型语言编写，如 Python，Ruby，并且解释器可用 于多个操作系统 
    2. 使用包含运行应用程序的虚拟机的语言编写的应用程序（如  Java） n 使用标准语言（如 C），在每个操作系统上单独编译以便在 每个操作系统上运行

4. 应用程序二进制接口（ABI）是 API 的体系结构等价物， 定义了不同二进制代码组件如何在给定操作系统、体系 结构、CPU 等条件下进行接口。

##  进程和线程

### 进程和线程的定义

操作系统执行应用程序是以进程的方式运行的

**进程**: 指正在执行的程序

**进程的构成**

1. 程序代码,  也叫文本段
2. 当前活动, 包括程序计数器, 处理器寄存器
3. 堆栈, 包括临时数据: 函数参数, 返回地址, 局部变量
4. 数据段: 包含全局变量的数据段
5. 堆: 在运行时动态分配的内存

### 进程状态及状态变迁

###  进程和线程之间的关系

###  线程的⼏种不同的实现⽅式 