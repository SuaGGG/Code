# 操作系统复习

## 操作系统基本概念

### 操作系统的定义和作用

#### 定义: 没有一个关于操作系统的完全准确的定义 

一个比较公认的定义是：操作系统是一直运 行在计算机上的程序（通常称为内核）。

 操作系统是管理系统资源、控制程序执行、 改善人机交互，为其它软件系统提供支持的 一种系统软件，是软件系统的核心。 

#### 作用

1. 让程序的运行更容易(允许多个程序运行)。

2. 允许程序共享内存。
3. 让程序能够与设备交互。

### 操作系统的功能

#### 管理计算机系统的软硬件资源

处理机 - 进程管理

存储器 - 内存管理

设备     - 设备管理

文件     - 文件系统管理

#### 提供保护与安全

控制进程或用户访问计算机系统资源

防止系统不受外部或内部的攻击

### 操作系统的特征

#### 并发

在同一时间间隔内发生两个或多个事件， 宏观上看是同时发生，微观上看是多个事件交替发生。

#### 共享

系统中的资源可供多个并发执行的进程共同使用。

​	互斥共享：一段时间只允许一个进程访问

​	同时访问：一段时间允许多个进程访问

​	时分复用，空分复用

​		并发与共享互为存在条件

​			程序的并发执行带来资源共享问题；

​			系统对资源共享的管理影响到程序并发执行的效率

#### 虚拟

把一个物理上的实体变为若干个逻辑上的对应物

​		分时技术，虚拟内存，虚拟设备

#### 异步

任务的执行顺序和每个任务的执行时间是不确定的

### 操作系统的分类

#### 批处理系统(多道程序设计)

批处理系统将作业(代码和数据)组织起来，使CPU始终有一个作业可以执行

系统中的作业的子集将被保留在内存中

通过作业调度选择并运行一个作业

当作业必须等待，操作系统会切换到另一个作业

##### 批处理技术

批处理技术时指计算机系统对一批作业自动进行处理的一种技术。

早期的批处理分为：**联机批处理**，**脱机批处理**。

###### 联机批处理

通过将若干个作业合成一批通过输入设备输入到磁带，接着通过**监督程序**自动把磁带上该批作业的第一个调入内存编译，然后由**装配程序**把编译结果装入内存启动执行，该作业运行结束后输出结果。然后重复执行上述操作，直到该批作业结束。

**联机批处理的不足**：联机批处理中采用**联机输入/输出**，即输入/输出操作在主机控制下进行，其缺点是**速度慢**。

###### 脱机批处理

在脱机批处理系统中，除主机外另设一台外围机。

用户作业通过外围机输入到磁带上，而主机只负责从磁带上把作业调入内存，并予以执行。

作业完成后，主机负责把结果输出到磁带上，然后再由外围机把磁带上的信息在打印机上输出。

![1703513779293](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703513779293.png)

**脱机输入/输出的优点：**

1.减少了CPU的空闲时间。

2.提高了I/O速度。

##### 单道批处理系统

内存中始终只保持一道作业的批处理系统。

**特征**：

1.自动性: 自动依次运行, 无人工干预.

2.顺序性:完成顺序与进入顺序相同.

3.单道性:内存只有一道作业.

#####  单CPU系统中多道程序运行特点 

1. **多道**: 计算机内存中同时存放多道相互独立的程序
2. **宏观上并行**:同时进入系统的多道程序都处于运行过程中，即它们先后开始了各自的 运行，但都未运行完毕
3.  **微观上串行**：内存中的多道程序轮流占有  CPU，交替执行

#####  多道批处理系统要解决的问题

1. 处理机管理: 如何分配回收处理机
2. 内存管理:  内存分配回收, 信息保护
3. 设备管理: 设备分配回收, 缓冲管理
4. 文件管理: 文件存储, 共享保护及检索
5. 作业管理: 作业合理搭配

#####  多道批处理系统的特征：

1. 多道性: 计算机内存中同时存放几道相互独立的程序
2. 无序性: 进入顺序与完成顺序无严格对应关系
3. 调度性: 作业从提交到完成经历两级调度: 作业调度, 进程调度



#### 分时系统(多任务处理)

CPU频繁切换作业，使用户能够在作业运行时与其交互，从而创建交互式运算

1. 响应时间应小于1秒
2. 每个用户至少有一个在内存中执行的程序，称为进程
3. 如果有多个作业同时准备进行，将进行CPU调度
4. 如果进程不能完全放入内存中，则进行交换以运行
5. 虚拟内存允许执行部分未完全加载到内存中的进程

在分时操作系统中,

1. 一个计算机和许多终端设备连接, 每个用户可以通过终端向系统发出命令, 请求完成某项工作, 而系统则分析从终端设备发来的命令, 完成用户提出的要求,
2. 然后用户再根据系统提供的运行结果, 向系统提出下一步请求
3. 这样重复上述交互会话过程, 直到用户完成全部工作为止

##### 分时技术

1. 把处理机的运行时间分成很短的时间片, 按时间片轮流把处理机分配给各联机作业使用
2. 若某个作业在分配给它的时间片内不能完成其计算, 则该作业暂停运行, 把处理机让给另一个作业使用, 等待下一轮时再继续其运行

#####  分时系统实现中的关键问题 

1. 及时接收: 设置多路卡
2. 及时处理: 时间片轮转

#####  分时操作系统的特征 

1. **同时性**: 一台计算机与若干台终端相连接, 终端上的这些用户可以同时使用计算机
2. **交互性**:用户通过终端采用人机会话的方式直接控制程序运行, 同程序进行交互
3. **独立性**:用户彼此之间都感受不到别人也在使用这台计算机, 好像只有自己独占计算机一样
4. **及时性**: 用户请求能在很短时间内获得响应

#### 实时系统

**实时系统**是指系统能及时响应外部事件的请求, 在规定的时间范围内完成对该事件的处理, 并控制实时任务协调一致地运行

##### 实时系统分类

1. 实时控制系统: 指以计算机为中心的生产过程控制系统
2. 实时信息处理系统: 要求对信息进行实时处理的系统

##### 实时系统的特征

1. 及时性: 响应时间由控制对象决定
2. 可靠性: 高可靠性

#### 个人计算机操作系统

**个人计算机操作系统**主要供个人使用, 它功能强, 价格便宜, 能满足一般人工作, 学习, 游戏等方面的要求

**个人计算机操作系统的主要特点**是计算机在某一段时间内为单个用户服务, 采用图形界面人机交互的工作方式, 界面友好, 使用方便

#### 网络操作系统

**网络操作系统**是基于计算机网络的, 是在各种计算机操作系统上按网络体系结构协议标准开发的**软件**

包括网络管理, 通信, 资源共享, 系统安全和各种网络应用服务, 其**目标是互相通信及资源共享**

#### 分布式操作系统

**分布式操作系统**是指多个分散的处理单元经互连网络连接而形成的系统,其中每个处理单元既具有高度自治又相互协同, 能在系统范围内实现资源管理, 任务动态分配, 并能并行地运行分布式程序

#### 嵌入式操作系统

对整个智能芯片以及它所控制地各种部件模块等资源进行统一调度, 指挥和控制的系统软件成为**嵌入式操作系统**

嵌入式系统几乎包括了生活中的所有电器设备, 如掌上PDA, 微波炉, 数字相机, 自动售货机, 工业自动化仪表与医疗仪器等

#### 分布式操作系统与网络操作系统的比较

1. **分布性**:分布式操作系统的处理和控制功能较均匀分布在系统的各个站点上; 而网络系统中控制功能大多集中在网络服务器上
2. **并行性**: 分布式操作系统中的任务分配程序可将多个任务分配到系统的多个处理单元上并行执行;而网络操作系统中每个用户的任务通常在自己的计算机上处理.
3. **透明性**:分布式系统能很好隐藏系统内部的实现细节, 对象的物理位置, 并发控制及系统故障等对用户是透明的; 而网络操作系统中主要是操作实现上的透明
4. **共享性**: 分布式操作系统中各站点上的资源可供所有用户共享; 而网络操作系统中共享的资源主要设置在服务器上
5. **健壮性**: 由于分布式系统的控制功能分布, 当站点故障时可以通过容错来重构系统以保证系统正常运行; 而网络操作系统中控制功能主要集中在服务器上, 使系统具有潜在的不可靠性



### 操作系统的基本类型

#### 三种基本类型

1. 批处理操作系统
2. 分时操作系统
3. 实时操作系统

#### 通用操作系统

**通用操作系统**是指一个操作系统兼由批处理, 分时和实时操作系统三者或两者的功能

### 操作系统的结构

#### 操作系统复杂度管理办法

管理复杂度系统的重要办法: **M.A.L.H**

1. **模块化**: 将复杂系统分解为一系列模块,通过明确定义的接口进行交互, 高内聚, 低耦合
2. **抽象**: 接口与内部实现分离, 模块通过抽象的接口进行交互, 而无需关心模块的内部实现
3. **分层**: 将模块按一定的原则进行层次划分，约 束模块只能同层或与相邻层交互 
4. **层级**: 功能相近的模块组成具有清晰接口的自 包含子系统，子系统再递归地组成有清晰接口 的更大子系统 

#### 分层结构

**分层结构**其实是一种**模块化思想**. 分层结构就和盖楼一样, 最底层为硬件层, 最高层为用户层, 每层只使用低层次的功能和服务, 也就是说上层可以调用下层的服务但不可以调用其它层的服务.

 ![img](https://pic2.zhimg.com/80/v2-96694fa5cea960383d33e7e03ce16e91_720w.webp) 

**分层结构的优点**: 简化了系统设计, 便于维护和升级维护

**分层结构的缺点**: 层的定义困难以及效率差.

#### 宏内核结构

所有的系统功能都放在内核里(宏内核结构在操作系统中也通常也采用了"模块化"思想)

**宏内核结构的优点**: 运行效率高

**宏内核结构的缺点**: 结构难以理解, 难以维护, 随着复杂性的增加, 可靠性和安全性难以保障

#### 微内核结构

微内核结构基于客户/服务器模型, 由微内核和核外用户空间的服务器进程构成

微内核保留进程管理, 内存管理和通信功能, 通过信息传递使客户程序与服务程序进行通信

**微内核结构的优点**: 易于扩展, 易于移植, 更可靠(内核代码少), 更安全

**微内核结构的缺点**: 用户空间到内核空间的通信增加了系统开销, 早期性能不及宏内核结构

#### 模块化结构

模块功能独立, 且被封装, 具有良好定义的接口

现代OS (如Unix, Linux, Windows等) 均采用模块化的策略组织各功能

没有商业OS是纯粹采用模块化结构设计

**模块化结构的优点**: 易于理解, 效率高

**模块化结构的缺点**: 全局函数使用多造成访问控制困难, 结构不清晰会导致可理解性, 可维护性及可移植性差, 存在潜在的性能退化

#### 混合结构

现代OS往往采用的不是单一模型

1. 混合模型结合多种方法来满足性能, 安全性和可用性需求
2. Linux 和 Solaris 是单内核结构, 但它们也是模块化的, 可动态向内核添加新功能
3. Windows也是单内核结构, 但也保留了微内核的模式来支持子系统, 也提供可加载的内核模块
4. MacOS是混合, 分层的系统, 采用Mach微内核与部分BSD Unix构成内核, 且有可动态加载的模块

###  操作系统的引导过程

#### 操作系统的构建和启动

OS 可运行于各种不同的系统上

从源码开始构建OS

1. 获取OS源码
2. 为某系统即将构建的OS配置参数
3. 编译OS
4. 安装OS
5. 启动计算机并运行OS

预编译的OS可能过于通用而无法支持特定的硬件

###### 构建Linux操作系统

1. 从http://www.kernel.org下载Linux源代码 
2. 使用“make menuconfig”命令配置内核。这一步生成 .config配置文件。
3. 使用“make”命令编译主内核。make命令根据.config文 件中的配置参数编译内核，生成内核镜像文件vmlinuz。
4. 使用“make modules”命令编译内核模块。与编译内核 类似，模块的编译也依赖于.config文件中指定的配置参 数。 
5. 使用“make modules install”命令将内核模块安装到 vmlinuz中。 
6. 使用“make install”命令将新内核安装到系统中。 

##### OS的引导过程(滚雪球方式)

1. 初始引导
    1. 系统加电
    2. 执行初始引导程序, 对系统硬件和配置进行自检, 保证系统没有硬件错误
    3. 从硬盘中读入操作系统引导程序, 并将控制权交给该程序模块
2. 引导程序执行
    1. 引导程序执行, 将操作系统核心文件读入内存, 并将控制交给核心的初始化程序
3. 内核初始化, 初始化系统数据结构及参数
    1. 系统加电建立进程有关的数据结构
    2. 获得自由存储空间的容量, 建立存储管理的数据结构
    3. 建立系统设备和文件系统的数据结构
    4. 初始化时钟
4. 系统初始化
    1. 完善OS的操作环境, 装载命令处理程序(或图形用户界面), 并初始化
    2. 在多用户系统中, 为每一个终端建立命令解释进程, 使系统处于命令接收状态

##### OS的启动流程

1. 引导加载程序加载OS内核到内存中
2. 内核初始化: OS内核进行一系列的初始化操作, 如硬件设备检查, 加载驱动, 内存管理等
3. 内核启动init进程: 内核初始化完成后, 会启动init进程(在Linux中) 或systemd进程, 该进程是所有其他进程的父进程
4. 用户空间程序启动: init进程根据系统的配置, 启动一系列的用户空间程序, 如 Shell, 图形界面等

#### 应用程序的处理步骤

1. 编辑: 建立一个新文件, 或对已有的文件中的错误进行修改
2. 编译: 将源程序翻译成浮动的目标代码
3. 连接: 主程序和其他所需要的子程序和例行程序连接装配在一起, 使之成为一个可执行的, 完整的主存映像文件
4. 运行: 将主存映像文件调入主存, 启动运行, 得出计算结果

##### 一个程序的典型执行流程

1. 加载: 当启动一个程序时, 由OS的加载器将该程序的可执行文件加载到内存中
2. 运行: OS创建一个新的进程, 并将CPU的控制权交给该进程. 该新进程开始执行加载到内存中的程序代码
3. 系统调用: 当程序需要进行一些特权操作(如读写文件, 发送网络数据等)时, 它将发起系统调用
4. 中断和信号: 程序的执行可能会被中断和信号打断. 中断通常是由硬件事件出发的, 如I/O操作的完成, 定时器的超时等. 信号则是一种软件中断, 可以由其他进程或者内核发送
5. 退出: 当程序执行完成或者由于某种原因需要停止时, 它将执行退出操作, 包括释放资源, 关闭打开的文件, 通知父进程等.

##  操作系统运⾏环境与运⾏机制

### 重要寄存器的作用

#### CPU的工作流程

1. 取指：CPU读取程序计数器（PC）中的地址作为指令的地址，从内存中读取指令。 
2. 译码：CPU将取得的指令进行译码，以确定它要执行的操作。
3. 执行：CPU执行指令的操作，可能涉及到算术、 逻辑、移位等操作。
4. 写回：CPU将执行结果写回到寄存器或内存中。 

#### CPU中的重要寄存器

1. 程序计数器（PC）：用于记录下一条要执行的指令的地址。当处理器执行完一条指令后，PC寄存器会自动更新为下一条指令的地址。 
2. 指令寄存器（IR）：IR寄存器用于记录最近取出并解码的指令。
3. 程序状态字（PSW）寄存器：PSW寄存器用于记录处理器的运行 状态，如条件码、模式、控制位等。PSW寄存器中的一些位可以影响处理器的行为，如中断允许位、处理器状态位等。
4. 通用寄存器（General Registers）：通用寄存器是一组可以被用户程序和操作系统程序使用的寄存器，用于保存数据或地址。 
5.  控制寄存器（Control Registers）：控制寄存器是一组只能被操作系统程序使用的寄存器，用于控制和配置处理器的一些特性和功能。 

### 操作系统的用户态和内核态

**CPU态**: 又称CPU的特权级, 是CPU的工作状态. 当前CPU正在执行哪类程序, 决定CPU的态.

区分处理机状态的目的: 保护操作系统

**内核态**:  操作系统的管理程序执行时机器所处的状态， 在此状态下处理机可使用全部指令(包括一组特权指令)；使用全部系统资源(包括整个存储区域)。 

**用户态**:  用户程序执行时CPU所处的状态，在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域。 

#### 用户态与内核态的区别

![1703536136697](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703536136697.png)

**CPU的特权指令集**: 涉及外部设备的输入/输出指令, 修改特殊寄存器的指令, 改变机器状态的指令

#### 不同架构的CPU的特权级

1. **ARM架构**: 定义了四个特权级别, 分别是User (用户模式), FIQ(快速中断模式), IRQ(中断请求模式) 和 SVC(超级用户模式). 用户模式是普通应用程序运行的模式, 而其他三种模式主要用于处理各种中断和异常
2. **RISC-V架构**:定义了四种特权级别, 分别是User(U), Supervisor(S), Hypervisor(H), Machine(M). User级别用于运行用户程序, Supervisor级别用于运行操作系统内核, Hypervisor级别用于运行虚拟机管理器, Machine级别则是硬件级别, 具有最高的特权
3. **X86架构**: 定义了四个特权级别, 从 Ring 0 到 Ring 3. 其中, Ring 0具有最高特权, 通常用于操作系统内核. Ring 1 到 Ring 2 很少使用, 而Ring 3具有最低特权, 用于运行用户程序

#### CPU特权级切换的三个场景

1. 应用程序调用操作系统提供的系统调用, 此时应用程序通过执行系统调用指令将CPU的特权级从用户态切换到内核态
2. 应用程序执行一条指令触发异常, 导致CPU的特权级从用户态切换到内核态, 比如访问内存指令触发了异常
3. 应用程序执行过程中, CPU收到了一条来自外设的**中断**, 对中断的处理导致CPU的特权级从用户态切换到内核态

### 中断和异常的工作原理

#### 中断机制中的常见功能

1. 中断一般通过中断向量将控制权转移到中断服务例程,  中断向量包含所有服务例程的地址
2. 中断架构必须保存被中断指令的地址
3. Trap或者异常是由错误或用户请求引起的软件生成的中断
4. 操作系统是中断驱动的

#### 中断响应

1. **中断响应**: 当中央处理机CPU发现已有中断请求时, 中止现行程序执行, 并自动引出中断处理程序的过程.
2. 中断响应需要硬件支持
    1. PC - 程序计数器
    2. PSW - 状态寄存器
    3. 系统堆栈 - 内存的固定区域
    4. 中断向量表 - 内存的固定区域

保护现场和恢复现场

**现场**: 在中断的那一时刻能确保程序继续运行的有关信息

1. 后继指令所在主存的单元号
2. 程序运行所处的状态
3. 指令执行情况
4. 程序执行的中间结果等

##### 保护现场

当中断发生时, 必须立即把现场信息保存在主存中

##### 恢复现场

程序重新运行之前, 把保留的该程序现场信息从主存中送至相应的指令计数器, 通用寄存器或一些特殊的寄存器中

#### 中断响应的详细过程

1. 中断响应过程
    1. 保留程序断点及CPU的状态信息
    2. 自动转入相应的中断处理程序
2. 中断响应的实质
    1. 交换指令的地址和CPU的状态信息

#### 中断处理程序

当硬件完成了中断进入过程后, 由相应的中断处理程序得到控制权, 进入了 软件的中断处理过程

![1703540560991](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703540560991.png)

#### 中断分类

1. 按中断来源分
    1. **中断**: 由处理机外部事件引起的中断
    2. **Trap**: 由处理机内部事件引起的中断
2. 按中断功能分类
    1. **输入输出中断**: I/O传输结束或出错中断
    2. **外中断**: 时钟中断, 操作员控制台中断, 通信中断等
    3. **机器故障中断**: 电源故障, 主存取指令错误等
    4. **程序性中断**: 定点溢出, 用户态下用内核态指令
    5. **访管中断**: 对操作系统提出某种需求时所发出的中断, 非法操作有时也被称为系统调用, 陷阱或者软件中断
3. 按中断方式分类
    1. **强迫性中断**: 不是正在运行的程序所期待的中断, 如: 输入输出中断, 外中断, 机器故障中断, 程序性中断
    2. **自愿中断**: 是运行程序所期待的事件. 如: 访管中断

### 系统调用的过程

**系统调用**

1. 是操作系统提供的服务的编程端口
2. 通常用高级语言编写
3. 大多数程序通过高级应用程序编程接口(API) 而不是直接使用系统调用
4. 最常见的三个API: Windows的Win32 API, 基于POSIX 的系统(包括几乎所有版本的UNIX, Linux 和 Mac OS X) 的 POSIX API, 以及 Java 虚拟机(JVM) 的 Java API

![1703541683146](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703541683146.png)

#### 系统调用的实现

1. 每个系统调用都与一个编号相关联

    系统调用接口根据这些编号维护一个索引表

2. 系统调用接口在操作系统内核中调用所需的系统调用, 并返回系统调用的状态和任何返回值

3. 调用者不需要了解系统调用的具体实现方式

    1. 只需要遵守API 并理解操作系统对调用的结果会做什么
    2. API将操作系统接口的大部分细节隐藏起来, 对程序员不可见
        1.  由运行时支持库管理（一组内置于编译器所包含的库中的 函数） 

####  访管中断 

1.  当处理机执行到访管指令时发生中断，该中断称 为访管中断，它表示正在运行的程序对操作系统 的某种需求。      

2. 操作系统提供实现各种功能的例行子程序，其中 的每一个功能对应访管指令的一个功能号。例如: 

    ​	svc  0 - 显示一个字符

    ​	svc  1 - 打印一个字符串

3. 系统调用是用户在程序一级请求操作系统服务的 一种手段，它是带有一定功能号的“访管指令”。 其功能是由操作系统中的程序完成的，即由软件 方法实现的。 

#### 系统调用的实现

![1703542309523](C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703542309523.png)

#### 系统调用的参数传递

1. 除了所需系统调用的标识符之外, 还需要更多的信息
2. 具体的信息类型和数量根据操作系统和调用而变化
3. 由三种常见的方法用于将参数传递给操作系统
    1. 将参数传递到寄存器中, 在某些情况下, 可能会有多个参数超过寄存器数量
    2. 将参数存储在内存中的快或者表中,  并将块的地址作为参数传递到寄存器中
    3. 程序将参数放置或推送到堆栈中, 并由操作系统从堆栈中弹出
    4. 快和堆栈方法不限制传递的参数数量或长度

#### 系统调用的类型

1. 进程控制    Process control 
2. 文件管理    File management 
3. 设备管理    Device management 
4. 信息维护    Information maintenance 
5. 通信            Communications 
6. 保护            Protection 

#### 为什么应用程序是OS特定的

1.  在一个系统上编译的应用程序通常无法在其他操作系统 上执行 

2. 每个操作系统都提供自己独特的系统调用 

    拥有自己的文件格式等 

3. 应用程序可以是多操作系统的 

    1. 使用解释型语言编写，如 Python，Ruby，并且解释器可用 于多个操作系统 
    2. 使用包含运行应用程序的虚拟机的语言编写的应用程序（如  Java） n 使用标准语言（如 C），在每个操作系统上单独编译以便在 每个操作系统上运行

4. 应用程序二进制接口（ABI）是 API 的体系结构等价物， 定义了不同二进制代码组件如何在给定操作系统、体系 结构、CPU 等条件下进行接口。

##  进程和线程

### 进程和线程的定义

操作系统执行应用程序是以进程的方式运行的

**进程**: 指正在执行的程序。从内核的观点， 进程的目的就是担当分配系统资源（CPU时间，内存等）的基本单位。

**线程**: 是进程的一个**执行流**， 是CPU调度和分派的基本单位， 它是比进程更小的能独立运行的基本单位。

**进程的构成**

1. 程序代码,  也叫文本段
2. 当前活动, 包括程序计数器, 处理器寄存器
3. 堆栈, 包括临时数据: 函数参数, 返回地址, 局部变量
4. 数据段: 包含全局变量的数据段
5. 堆: 在运行时动态分配的内存

#### 进程控制块(Process Control Block) 

管理程序运行的数据结构

1. 进程状态：运行，等待， 就绪等
2. 程序计数器： 下一条指令的位置
3. CPU寄存器： 所有进程相关寄存器的内容
4. CPU调度信息： 优先级， 调度队列指针
5. 内存管理信息：分配给进程的内存
6. 记账信息： CPU使用情况， 自启动以来经过的时钟时间， 时间限制
7. I/O状态信息：分配给进程的I/O设备， 打开文件列表

#### 程序如何转化为进程？

1. 将代码和静态数据加载到内存
2. 为程序的运行时栈分配内存
3. 为程序的堆分配内存
4. 执行与I/O相关的设置
5. 启动程序的运行

程序是存储在磁盘上的被动实体（可执行文件）； 进程是活动的。当可执行文件被加载到内存中时， 程序变成进程。通过GUI鼠标点击或命令行输入其名称等，启动程序的执行。

一个程序可以有多个进程

#### 进程的内存映像

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703555128897.png" alt="1703555128897" style="zoom: 50%;" />

1. 文本区/代码区: 存放**程序的机器代码**， 通常只读，以防止恶意修改或意外修改
2. 数据区：存放**全局变量**和**静态变量**
3. 堆：用于**动态内存分配**的区域
4. 栈：用于存储**函数调用**的**上下文信息**

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703555411247.png" alt="1703555411247" style="zoom:60%;" />

#### PCB包含的主要内容

1. **进程标识符**(PID): 惟一标识进程的一个标识符或整数ID号
2. **进程当前状态**: 说明进程当前所处状态
3. **进程队列指针**: 用于记录PCB队列中下一个PCB的地址
4. **程序和数据地址**: 进程的程序和数据在内存或外存中的存放地址
5. **CPU现场保护区**: CPU现场信息的存放区域， 包括： 通用寄存器， 程序计数器，程序状态字等
6. **通信信息**: 进程与其他进程所发生的信息交换时所记录的有关信息1
7. **家族关系**: 指明本进程与家族的关系， 如父子进程标识
8. **资源清单**: 列出进程所需资源及当前已分配资源

**(Linux更加详细请见" [sched.h « linux « include - kernel/git/next/linux-next.git - The linux-next integration testing tree](https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/tree/include/linux/sched.h?h=next-20231222) "里面中的task_struct结构体， 大概在700 - 800行)**

### 进程状态及状态变迁

#### 进程状态

进程运行时， 状态会发生变化

1. **新建 New**: 进程被创建
2. **运行 Running**:  指令执行时的状态
3. **等待 Waiting**: 进程等待某些事件发生时的状态
4. **就绪 Ready**: 进程等待获得CPU
5. **终止 Terminated**: 进程正常或异常结束时的状态

#### 状态转换说明

1. 大多数状态不可逆装， 如等待不能转化为运行
2. 状态转换大多为被动执行， 但运行 -> 等待是主动的
3. 一个进程在一个时刻只能处于上述状态之一

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703555705048.png" alt="1703555705048" style="zoom:67%;" />

#### 上下文切换

1. 当CPU切换到另一个进程时， 系统必须通过上下文切换保存旧进程的状态， 加载新进程的状态
2. 进程的上下文保存在PCB中
3. 上下文切换时间是**纯开销**，系统在切换时不执行任何有用的工作**（操作系统和PCB越复杂 -> 上下文切换时间就越长）**
4. 时间开销取决于硬件支持（某些硬件为每个CPU提供多组寄存器 -> 一次要加载多个上下文）

#### 进程的挂起状态

1.  进程的挂起指的是进程因为某种原因暂时不能继续执行，需要等待某个事件的发生或者满足某种条件后才能恢复执行。

2.  在挂起状态下，进程会被保存在**磁盘**上，不占用内存资源，也不占用CPU时间。 

3. 进程挂起的原因有：1. 用户请求 2. 系统资源不足 3. 进程间的通信 4. I/O操作

    5.错误或异常

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703556279157.png" alt="1703556279157" style="zoom:67%;" />

#### 怎么对进程进行控制？

1. 通过OS内核提供的系统调用对进程进行管理
2. 常用的进程控制系统调用
    1. 创建
    2. 终止
    3. 阻塞（等待）
    4. 唤醒
3. 上述功能由**原语**来实现， 即**系统调用代码在执行期间不可分割**

##### 进程创建

**功能**: 创建一个具有指定标识符的进程， 建立进程的PCB结构

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703557377292.png" alt="1703557377292" style="zoom:67%;" />

1. 父进程创建子进程， 子进程又创建子进程， 从而形成**进程树**
2. 通常进程通过进程标识符(PID) 进行标识和管理
3. 父子进程的资源共享
    1. 父进程和子进程共享所有资源
    2. 子进程共享父进程资源的子集
    3. 父进程和子进程不共享任何资源
4. 父子进程的执行
    1. 父进程和子进程并发执行
    2. 父进程等待子进程终止
5. 地址空间
    1. 子进程是父进程的副本
    2. 子进程中加载了一个程序
6. UNIX 示例
    1. fork() 系统调用创建新进程
    2. exec() 系统调用在 fork() 之后使用， 用于将进程的内存空间替换为新程序
    3. 父进程调用wait() 等待子进程终止

##### 导致进程创建的原因

1. **用户登录**: 用户登录后， 若合法则为用户创建一个进程。
2. **作业调度**：为调度到的作业分配资源并创建进程。
3. **OS服务**: 创建服务进程。
4. **应用需要**：应用程序根据需要创建子进程。

##### 进程终止

**功能**：终止当前运行的进程。将该进程的PCB结构归还到PCB资源池， 所占用的资源归还给父进程， 从总链队列中移除， 然后转进进程调度程序。

1. 进程执行最后一条语句， 然后通过exit()系统调用请求操作系统删除它
    1. 通过wait()将状态数据从子进程返回给父进程
    2. 进程的资源由操作系统释放
2. 父进程可以使用abort()系统调用终止子进程的执行。一些终止子进程的原因包括:
    1. 子进程超过了分配的资源
    2. 分配给子进程的任务不再需要
    3. 父进程正在退出， 如果父进程终止， 操作系统不允许子进程继续执行
3. 如果父进程终止， 则某些操作系统不允许子进程存在。 如果一个进程终止， 则其所有子进程也必须终止。
    1. **级联终止**。所有子进程都将被终止。
    2. 终止由操作系统发起。
4. 父进程可以使用wait()系统调用等待子进程的终止。该调用放回状态信息和已终止进程的PID。
5. 如果没有父进程等待， 则该进程是**僵尸进程**。
6. 如果父进程终止而没用调用wait(), 则该进程为**孤儿进程**。

##### 引发进程终止的原因

1. **正常退出**：进程完成了它的任务并正常退出， 通过调用退出系统调用（如Linux的exit()）实现
2. **错误退出**： 如果进程遇到无法处理的运行时错误，如除以零或访问无效内 存，它可能会被操作系统终止 
3. **致命错误**： 某些严重的错误，如硬件错误或操作系统错误，可能导致进程被终止 
4. **由其他进程终止**： 一个进程可以请求操作系统终止另一个进程。这通常通 过发送一个信号（如 Unix 或 Linux 的 kill）或调用一个系统调用（如  Windows 的 TerminateProcess()）实现 
5. **用户请求**： 用户可以请求操作系统终止一个进程。这可以通过命令行（如  Unix 或 Linux 的 kill 命令）或图形用户界面（如任务管理器）实现 
6. **操作系统干预**： 如果进程使用了过多的系统资源（如 CPU 时间或内存）， 或者它的行为违反了操作系统的策略（如优先级太低而 CPU 时间不足）， 操作系统可能会终止它 
7.  **父进程终止**： 在某些操作系统中，如果父进程被终止，它的子进程可能也会被终止  
8. **系统关机或重启**：当操作系统关机或重启时，所有正在运行的进程都会被终止。

##### 进程阻塞(等待)

**功能**：暂停进程的执行，并将其加入到等待某事件的等待队列中；将控制转向进程调度

#####  引发进程阻塞的事件 

1. **I/O请求**：进程发出I/O请求并等待其完成时，例如读写磁盘文件或网络数据
2. **等待子进程**：父进程使用如wait()这样的系统调用等待一个或多个子进程终止
3. **信号或消息**：进程等待接收特定的信号或消息
4. **资源占用**：进程等待获取互斥锁， 信号量或其他同步原语。
5. **内存页错误**：进程访问的内存页不在物理内存中，需要从磁盘中调入。

##### 进程唤醒

**功能**：当进程等待的事件发生时，由事件发现者唤醒等待该事件的进程。

#####  引发进程唤醒的事件

1. **I/O 完成**：进程发出的 I/O 请求已完成。 
2. **子进程终止**：进程等待的子进程已终止。
3. **接收到信号或消息**：进程接收到了它正在 等待的信号或消息。 
4. **获取资源**：进程等待的资源（如互斥锁、 信号量）已经可用。 
5. **内存页调入完成**：进程等待的内存页已经 被调入物理内存。

#####  挂起原语的功能实现 

1.  将进程的状态设置为挂起状态 
2. 如果进程在CPU中执行，那么保存进程的上下文信息， 包括程序计数器， 寄存器值， 内存映射等信息
3. 将进程的上下文信息和其他相关数据结构写入磁盘
4. 将进程从调度队列中移除

#####  挂起原语的主要功能

挂起原语的主要功能是将指定进程挂起，算法思想如下：

1. **查表**：到PCB表中查找该进程的PCB
2. **检查进程状态**：如果是该进程已经处于挂起状态或者由于其他原因（等待I/O操作） 无法被挂起， 那么挂起原语会返回一个错误；
3. **更改进程状态**： 如果目标进程可以被挂起，那么挂起原语会 将其状态从当前状态（如运行或就绪）更改为挂起状态； 
4. **保留进程上下文**： 这样当进程被重新激活时，它可以从中断 的地方恢复执行； 
5. **更新PCB**： 挂起原语会更新PCB，反映进程的新状态和上下文信息；
6. **调整调度队列**：  将目标进程从就绪队列中移除，并将其添加 到一个专门的挂起队列中。这样，操作系统的调度器就不会 再选择这个进程进行执行，从而实现了进程的挂起。 

#####  激活原语的主要功能 

激活原语的主要功能是将指定进程激活，算法思想如下： 

1. **查表**： 到PCB表中查找该进程的PCB 
2. **检查进程状态**：如果该进程不处于挂起状态，那么激活原语会返回一个错误
3. **更改进程状态**： 如果目标进程处于挂起状态，那么激活 原语会将其状态从挂起状态更改为就绪状态 
4. **恢复进程上下文**： 激活原语会恢复进程的上下文信息， 这样，当进程被重新调度执行时，它可以从中断的地方恢复执行 
5. **更新PCB**： 激活原语会更新PCB，反映进程的新状态和 上下文信息 
6. **调整调度队列**： 将目标进程从挂起队列中移除，并将其 添加到就绪队列中。这样，操作系统的调度器就可以再 次选择这个进程进行执行，从而实现了进程的激活。 

###  进程和线程之间的关系

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703561233435.png" alt="1703561233435" style="zoom:50%;" />

#### 多线程的优势

1. **响应性**： 进程在某个部分被阻塞的情况下被 允许继续执行，对于用户界面尤其重要 
2. **资源共享**： 线程共享进程的资源，比共享内存或消息传递更容易 
3. **经济性**： 比进程创建的开销小，线程切换的 开销比上下文切换低 
4. **可扩展性**： 进程可以利用多核架构的优势 

**进程**

1. 是系统进行资源分配和调度的一个独立单位；
2. 有自己的独立内存空间，包括代码段， 数据段和 堆栈段等；
3. 进程间通信需要使用进程间通信（IPC）机制， 如管道， 消息队列等

**线程**

1. 是CPU调度和分派的基本单位， 是比进程更小的能独立运行的基本单位
2. 一个进程可以包含多个线程， 线程运行在同一内存空间，共享相同的运行环境
3. 线程之间可以直接读写同一进程中的数据， 线程间的通信更加便捷

**关系**

1. 线程是属于进程的， 它们可以被看作是在进程内部的一个个独立的 执行路径
2.   一个进程内的多个线程之间共享该进程的资源，如内存空间、文件等
3.  线程间的通信比进程间的通信更简单，线程的切换开销也比进程切换要小

#### 多线程进程的地址空间布局

1. 分离的内核栈和用户栈
    1. 每个线程都有自己的栈， 用于存放临时数据
    2. 用户线程切换到内核中执行时，栈指针则切换到对应的内核栈
2. 共享其他区域
    1. 除栈以外的其它区域， 进程内的所有栈共享
    2. 一个进程的多个线程需要动态分配内存时，将在同一个堆上完成

#### 线程的组成

1. 线程控制块（TCB）：TCB是线程的大脑， 他存储了操作系统需要管理和调度线程所需要的所有信息。包括：
    1. 线程标识符
    2. 线程状态（如运行，就绪，阻塞）
    3. CPU寄存器值（PC, PS 和通用寄存器）
    4. 线程优先级
    5. 所属进程的引用
2. 内核级TCB
    1. 内核堆栈
    2. CPU调度信息（如CPU使用时间）
    3. 内核资源使用情况
3. 用户级TCB
    1. 用户堆栈
    2. 用户资源使用情况

###  线程的⼏种不同的实现⽅式

#### 	内核级线程

1. 线程由操作系统内核直接支持和管理
2. 每个内核级线程都有自己在内核中的数据结构， 其中包含了如 线程状态、优先级、 调度信息等重要数据； 
3.  内核级线程可以直接由操作系统调度，因此它们可 以在多处理器系统上并行运行 
4.  如果一个内核级线程阻塞（例如等待I/O操作完成）， 操作系统可以立即调度同一进程中的另一个线程运行； 
5.  内核级线程的创建、销毁、同步和切换都需要进行 系统调用，因此这些操作的开销相对较大。 

#### 用户级线程

1.  线程完全在用户空间中实现，不需要内核的支持； 
2.  用户级线程的创建、销毁、同步和切换都是由相应 的用户级线程库来完成的，这些操作通常比内核级 线程的对应操作要快得多； 
3.  操作系统只看到进程而不是用户级线程，所以它不 能直接调度用户级线程，也不能在多处理器系统上 并行运行用户级线程； 
4.   如果一个用户级线程阻塞（例如等待I/O操作完 成），整个进程（包括所有其他用户级线程）都会 被阻塞。 

#### 混合线程模型

1.  Java虚拟机（JVM）采用了一种混合线程模型， 可以兼顾内核级线程和用户级线程的优点 
2.  JVM可以创建多个内核级线程，并在每个内核 级线程上运行多个用户级线程 
3.  JVM就可以利用多处理器系统的并行能力，同 时也可以通过在用户空间进行线程切换来减小开销 

####  多线程模型 

1. 多对一模型
    1.  多个用户级线程映射到单个内核线程 
    2.  一个线程的阻塞会导致所有线程都被阻塞 
    3.  在多核系统上，多个线程可能无法并行运行，因 为一次只能有一个线程在内核中运行 

1. 一对一模型
    1.  每个用户级线程映射到内核线程 
    2.  创建一个用户级线程会创建一个内核线程 
    3.  比多对一模型具有更多的并发性 
    4.   由于开销的原因，每个进程中的线程数量有 时会受到限制 
2. 多对多模型
    1.  允许多个用户级线程映射到多个内核线程 
    2.  允许操作系统创建足够数量的内核线程 
    3.  Windows使用的ThreadFiber包 

####  两级模型

1.  类似于多对多模型 
2.  用户级线程可以被映射到任意数量的内核级线程 上。这意味着一个用户级线程可以对应一个内核 级线程，也可以对应多个内核级线程 
3.  该模型提供了更大的灵活性，可以根据应用程序 的需要进行优化，可以利用到多处理器的并行性 

##  进程线程调度

### 进程调度的基本概念

#### 引发进程调度的原因

1. 系统面临同时处理多个资源请求，但系统资源有限

#### 进程调度的过程

1. 任务数量远远超过CPU核心
2. 调度器通过委会运行队列的方式来管理任务
3. 任务触发以下条件会停止执行：
    1. 执行了指定的时间片
    2. 任务发起了I/O请求
    3. 任务主动停止
    4. 任务被系统中断打断
4. 调度器的作用
    1. 从队列中选择下一个执行的任务
    2. 决定执行该任务的CPU核心
    3. 决定该任务允许执行的时间大小

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703572850860.png" alt="1703572850860" style="zoom:70%;" />

#### 调度机制

**进程的多级调度**

1. **长程调度**：当一个程序尝试运行时，OS是否立刻为其创建相应的进程；  长程调度决定当前真正可被调度的进程的数量 
2. **短程调度**： 负责进程在就绪，运行和阻塞状态间的转换；触发短程调度的事件：进程创建， 执行结束，硬件中断（特别是时钟中断），系统调用等
3. **中程调度**：负责避免内存使用过多；中程调度是换页机制的一部分

**长程调度**：负责调控系统整体， 为进程带来额外时延

**中程调度**：负责监控内存资源使用情况

**短程调度**：决定进程是否可执行

#### CPU调度器

1. CPU调度器从就绪队列中选择进程，并将CPU核心分配给其中一个进程
2. 就绪队列可以通过多种方式排序
3. 当进程出现以下情况时，需要进行CPU调度决策：
    1. 进程从运行状态变成等待状态
    2. 进程从运行状态变成就绪状态
    3. 进程从等待状态变成就绪状态
    4. 终止
4. 对于情况a 和 d，调度器必须选择要执行的新进程

#### 抢占式和非抢占式调度

1. 当调度仅在情况a 和 d下进行时，调度方案是非抢占式的，否则，就是抢占式的
2. 非抢占式调度：一旦将CPU分配给进程，该进程将保持CPU，直到通过终止或者切换到等待状态释放它；潜在问题：如果一个进程长时间占用CPU，其他进程可能被迫等待很长时间，从而导致响应时间变慢。
3.  几乎所有现代操作系统，包括Windows， macOS，Linux和UNIX，都使用抢占式调度 算法。 

#### 调度程序

1. 调度程序将CPU的控制权交给CPU调度器选出来的进程：切换上下文，切换用户模式，跳转到用户程序的适当位置来启动程序
2. 调度延迟：调度程序停止一个进程并启动另一个进程运行所需要的时间

### 进程调度算法评价准则

1. **CPU利用率**：衡量CPU被有效利用的程度的指标。理想情况下，希望CPU一直被占用
2. **吞吐量**：衡量单位时间内系统完成任务数量的指标
3. **周转时间**：从**任务提交到任务完成**所经过的时间，包括等待时间和执行时间
4. **等待时间**：衡量任务在就绪队列中等待的总时间
5. **响应时间**：从任务提交到首次开始执行所经过的时间

### 经典进程调度算法（单核）

#### 先来先服务（FCFS）

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703574133867.png" alt="1703574133867" style="zoom:67%;" />

#### 最短作业优先（SJF）

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703574279689.png" alt="1703574279689" style="zoom:67%;" />

#### 最短剩余时间优先（SRT）

是抢占式的 SJF版本， 对于每一个新进程进入到就绪队列中，我们判断最短剩余时间来排序（优先队列 - 小根堆）

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703574439491.png" alt="1703574439491" style="zoom:67%;" />

#### 最高响应比优点（HRRN）

**响应比**： （等待时间 + 服务时间） /  服务时间

选择响应比高的进程执行

非抢占式的调度运算，旨在公平地处理各种长度的作业，同时尽量减少作业的平均等待时间和平均周转时间

**等待时间相同， 短作业优先**

**运行时间相同，等待时间长的作业优先**

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703574740406.png" alt="1703574740406" style="zoom:67%;" />

#### 时间片轮转（RR）

每一个进程获得一小段CPU时间（时间片q），通常为10 - 100 毫秒。此时间用完之后，进程会被抢占并添加到就绪队列的末尾

若就绪队列中有n个进程且时间片为q， 则每个进程一次最多获得CPU时间的 $\frac1n$, 进程等待不会超过$(n - 1) \ * \ q $个时间片

时间片到，由计时器发出中断以调度下一个进程

**性能**：Q设置过大，则退化成FIFO；Q设置过小，则开销太高，因此Q必须大于上下文切换时间

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703575362428.png" alt="1703575362428" style="zoom:67%;" />

#### 优先级调度

1. 每个进程都与一个优先级数字（INT）相关联

2. CPU分配给具有最高优先级的进程（通常， 数字越小，优先级越高）

3. 两种方案：抢占和非抢占式优先级调度

4. 问题：饥饿 - 低优先级进程可能永远不会执行

5. **解决方案**：老化 - 随着时间的推移，增加进程的优先级

    **注意：**SJF可以看做是优先级调度，其中优先级预测的是下一个CPU执行时间的倒数

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703575651087.png" alt="1703575651087" style="zoom:67%;" />

##### 结合RR的优先级调度

调度最高优先级的进程，若进程优先级相同，则按RR方式调度

##### 多级队列

1. 就绪队列由多个队列构成
    1. 不同的优先级都有各自独立的队列
    2. 调度从最高优先级开始
2. 根据进程的类别来确定优先级

##### 多级反馈队列

1. 一个进程可以在各个队列中移动
2. 多级反馈队列的调度程序由一下参数定义：
    1. **队列数量**
    2. **每个队列的调度算法**
    3. **何时升级进程的方法**
    4. **何时降级进程的方法**
    5. 进程将进入哪个队列的方法
3. 可以通过多级反馈队列来实现老化机制，防止低优先级进程长时间等待

<img src="C:\Users\23219\AppData\Roaming\Typora\typora-user-images\1703576055588.png" alt="1703576055588" style="zoom:67%;" />

### 多处理器调度的亲和性

#### 多处理器架构

**定义**：1. 多处理器架构：指一个计算机系统中包含了两个或更多的处理器，这些处理器可以并行执行多个任务， 以提高系统的性能； 2. 主要优点：可以实现任务的并行处理， 从而提高系统的吞吐量和性能

##### 多处理器架构的分类

1. 按连接方式和资源共享方式分类
    1. **紧藕合多处理器**：在一个系统中有多个处理器共享同一个存储器和I/O设备，所有处理器可以访问所有的存储和设备。优点是资源共享， 缺点是需要复杂的硬件和软件支持
    2. **松藕合多处理器**： 在一个系统中有多个处理器， 每个处理器都有自己的存储器和I/O设备，处理 器之间通过通信网络连接。优点是简单，易于扩展，缺点是资源利用率低。 
2. 根据多处理器的工作方式分类
    1. 对称多处理器（SMP）： 在SMP系统中，所有处理器都是对等的，任何一个处理器都可以执行任何一个任务，所有的处理器共享同一存储器和I/O设备。
    2. 非对称多处理器：在非对称多处理器系统中，不同的处理器有不同的任务，例如，一些处理器专门用于I/O操作，一些处理器专门用于计算

#### 调度对多处理器架构的影响调度目标

1. 调度算法如何将任务分配不同的处理器，以达到性能最优
2. 调度算法如何满足任务之间的依赖关系， 确保任务按正确的顺序执行

#### 多处理器架构带来的问题

1. 多CPU的情况下的缓存一致性问题
2. 缓存亲和度问题

